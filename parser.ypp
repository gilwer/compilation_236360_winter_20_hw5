

%{
	/*C user declerations*/
	#include "source.h"
	#include "hw3_output.hpp"
	#include "bp.hpp"
	#include <iostream>
	#include <stack> 
	#include <map> 
	#include <vector>
	#include <numeric>
	#include <string>
	#include "symbol_table.h"
	#define YYDEBUG 1 
	#define CB CodeBuffer::instance()
	using namespace std;
	using namespace compi3;
	int yylex();
	extern int yylineno;
    SymbolTable sm;
	int isLoop;
	vector<string> func_arg_types;
	string funcRet;
	string funcId;
	int func_arg_offset;
	int offset;
	bool isRetEnum;
	void yyerror(const char*);
	void endSScope();
	int currentVar=0;
	string freshVar();
	void createZeroDivisionLabel();
	const string ZeroDivisionLabel = "zero_division_label";
	const string zero_error = "Error division by zero";
 	string arglist(int size);
 	string callList(vector<string> list,vector<string> types);
 	bool manual_return = false;
 	void emitPrintFuncs();
 	string accumulateHelper(string a,string b);
 	void allocateStackVars();
 	string token_to_op_str(string token);
 	int open_scope();
 	int close_scope(int address,string return_label);

%}



%left    VOID
%left    INT
%left    BYTE
%left    B
%left    BOOL

%left    WHILE  
%left    SC
%left    COMMA

%left    LBRACE
%left    RBRACE
%right    ASSIGN
%left    BINOP
%token    ID NUM TRUE FALSE STRING CONTINUE BREAK RETURN
%left    OR
%left    AND
%left	 EQUAL
%nonassoc    RELOP
%left    PLUS
%left    MULT
%right    NOT
%left    RPAREN
%left    LPAREN
%left    ENUM
%left NO_ELSE
%left    ELSE
%left    IF



%%

Program		: Enums Funcs {}
			;

Funcs   	: /*epsilon*/ {}
			| FuncDec Funcs {}
			;

FuncDec 	: RetType ID LPAREN {
                    if(sm.is_symbol_defined($2.str)){
                        output::errorDef(yylineno,$2.str);
                        exit(1);
                    }
                    funcId = $2.str;
                    func_arg_offset = -1;
                    offset = 0;
                    sm.open_scope();
                } formals RPAREN LBRACE {
                    funcRet = $1.type;
                    func_arg_types = *$5.argTypes;
                    string type =$1.type=="VOID"?"void":"i32";
                    string args = arglist(func_arg_types.size());
                    CB.emit("define "+type+" @"+$2.str+"(" + args +") {");
                    if($1.type!="VOID"){
                    	CB.emit("%retvar = alloca i32");
                    	CB.emit("store i32 0, i32* %retvar");
                    }
                    $3.val=open_scope();
                    CB.emit($2.str + ".return:");
                    string ret_exp = "void";
                    if($1.type!="VOID"){
                     	string ret = freshVar();
                     	CB.emit(ret + " = load i32, i32* %retvar ");
                     	ret_exp = "i32 "+ ret;
                    }
                    CB.emit("ret " + ret_exp);
                    $3.instr = CB.genLabel();
  				} Statements RBRACE {
  					CB.emit("br label %"+ $2.str + ".return");
  					createZeroDivisionLabel();
  					offset -= close_scope($3.val,$3.instr);
                    CB.emit("}");
                    manual_return = false;
                    
                    vector<string> args = *$5.argTypes;
                    sm.define_func_symbol($2.str,$1.str,false,args);
                    delete $5.argTypes;
                    funcId="";


			}
			;

Enums 		: /*epsilon*/ {}
			| EnumDecl Enums {}
			;

EnumDecl	: ENUM ID LBRACE EnumeratorList RBRACE SC {
				if(sm.is_symbol_defined($2.str) || $2.str==funcId){
					output::errorDef(yylineno,$2.str);
					delete $4.argTypes;
					exit(1);
				}
				vector<string> args = *($4.argTypes);
				string error = sm.define_enum_symbol($2.str,args);
				if(error!=""){
					output::errorDef(yylineno,error);
					delete $4.argTypes;
					exit(1);
				}
				delete $4.argTypes;
				}
			;

RetType     : Type {$$ = $1;}
			| VOID {$$.type = "VOID";}
			;

formals   	: /*epsilon*/ {
				$$.argTypes = new vector<string>;
				}
			| FormalsList {
				$$=$1;
				}
			;

FormalsList : FormalDecl {
				$$.argTypes = new vector<string>;
				$$.argTypes->push_back($1.type);
				}
			| FormalDecl COMMA FormalsList {
				$$.argTypes = new vector<string>;
				$$.argTypes->push_back($1.type);
				$$.argTypes->insert($$.argTypes->end(),$3.argTypes->begin(),$3.argTypes->end());
				delete $3.argTypes;
				}
			;

FormalDecl  : Type ID {
				if(sm.is_symbol_defined($2.str ) || $2.str==funcId){
					output::errorDef(yylineno,$2.str);
					exit(1);
				}
				$$.str = $2.str;
				$$.type = $1.type;
				$$.isEnum = false;
				sm.define_symbol($$.str,$$.type,$$.isEnum,func_arg_offset--);
			}
			| EnumType ID {
				delete $1.argTypes;
				if(sm.is_symbol_defined($2.str) || $2.str==funcId){
					output::errorDef(yylineno,$2.str);
					exit(1);
				}
				$$.str = $2.str;
				$$.type = $1.type;
				$$.isEnum = true;
				sm.define_symbol($$.str,$$.type,$$.isEnum,func_arg_offset--);
			}
			;

EnumeratorList  : Enumerator {
					$$.argTypes = new vector<string>;
					$$.argTypes->push_back($1.str);
					}
				| EnumeratorList COMMA Enumerator {
					$$.argTypes = new vector<string>;
					$$.argTypes->insert($$.argTypes->end(),$1.argTypes->begin(),$1.argTypes->end());
					$$.argTypes->push_back($3.str);
					delete $1.argTypes;
					}
				;

Enumerator 	: ID	{
				if(sm.is_symbol_defined($1.str) || $1.str==funcId){
					output::errorDef(yylineno,$1.str);
					exit(1);
				}
				} 
			;

Statements  : Statement {}
			| Statements Statement {}
			;



Call 		: ID LPAREN ExpList RPAREN {
				if((!sm.is_symbol_defined($1.str) ||  sm.get_var_type($1.str).find("->") == string::npos) && funcId!=$1.str){
					output::errorUndefFunc(yylineno,$1.str);
					delete $3.argTypes;
					exit(1);
				}
				vector<string> argTypes1 = funcId!=$1.str?sm.get_func_args($1.str):func_arg_types;
				vector<string> argTypes2 = *($3.argTypes);
				for(auto i = argTypes1.begin(), j = argTypes2.begin();i!=argTypes1.end()&&j!=argTypes2.end();i++,j++){
					if(*i!=*j && !(*i=="INT" && *j=="BYTE")){
						output::errorPrototypeMismatch(yylineno,$1.str,argTypes1);
						delete $3.argTypes;
						exit(1);
					}
				}
				if(argTypes2.size() != argTypes1.size()){
					output::errorPrototypeMismatch(yylineno,$1.str,argTypes1);
					delete $3.argTypes;
					exit(1);
				}
				$$.type = funcId!=$1.str?sm.get_func_ret($1.str):funcRet;;
				
				$$.lineno = yylineno;
				string type = "void";
				string ret = "";
				if($$.type!="VOID"){
					$$.str = freshVar();
					type = "i32";
					ret = $$.str + " = ";
				}
				if($1.str != "print"){
					CB.emit(ret + "call "+ type + " @"+$1.str + "(" + callList(*($3.args),*($3.argTypes)) + ")");
				} else {
					string id = freshVar().substr(1);
					int len = (*($3.args))[0].length()-2;
					string str =  (*($3.args))[0].substr(1,len);
					CB.emitGlobal("@."+id+" = constant ["+ to_string(len+1) +"x i8] c\"" + str + "\\00\"");
					CB.emit("call void @print(i8* getelementptr (["+ to_string(len+1) +" x i8], ["+to_string(len+1)+" x i8]* @."+id+", i32 0, i32 0))" );
				}
				delete $3.argTypes;
				delete $3.args;
				}
			| ID LPAREN RPAREN {
				if((!sm.is_symbol_defined($1.str) ||  sm.get_var_type($1.str).find("->") == string::npos) && funcId!=$1.str){
					output::errorUndefFunc(yylineno,$1.str);
					exit(1);
				}
				vector<string> args = funcId!=$1.str?sm.get_func_args($1.str):func_arg_types;
				if(!args.empty()){
					output::errorPrototypeMismatch(yylineno,$1.str,args);
					exit(1);
				}
				$$.type = funcId!=$1.str?sm.get_func_ret($1.str):funcRet;
				$$.isEnum = sm.is_enum($1.str);
				$$.lineno = yylineno;
				string type = "void";
				string ret = "";
				if($$.type!="VOID"){
					$$.str = freshVar();
					type = "i32";
					ret = $$.str + " = ";
				}
				CB.emit(ret + "call "+ type + " @"+$1.str + "()");
			}
			;

ExpList     : Exp {
				$$.argTypes = new vector<string>;
				$$.argTypes->push_back($1.type);
				if($1.type == "BOOL"){
					string true_label = CB.genLabel();
					CB.bpatch($1.truelist,true_label);
					int true_address = CB.emit("br label @");
					string false_lable = CB.genLabel();
					CB.bpatch($1.falselist,false_lable);
					int false_address = CB.emit("br label @");
					string next = CB.genLabel();
					CB.bpatch(CB.merge(CB.makelist(make_pair(true_address,FIRST)),CB.makelist(make_pair(false_address,FIRST))),next);
					string tmp = freshVar();
					CB.emit(tmp + " = phi i1 [ true, %" + true_label+ " ], [ false, %"+ false_lable +" ]");
					$1.str = tmp;
				}
				$$.args = new vector<string>;
				$$.args->push_back($1.str);
			}
			| Exp COMMA ExpList {
			$$.argTypes = new vector<string>;
			$$.argTypes->push_back($1.type);
			$$.argTypes->insert($$.argTypes->end(),$3.argTypes->begin(),$3.argTypes->end());
			delete $3.argTypes;
			if($1.type == "BOOL"){
					string true_label = CB.genLabel();
					CB.bpatch($1.truelist,true_label);
					int true_address = CB.emit("br label @");
					string false_lable = CB.genLabel();
					CB.bpatch($1.falselist,false_lable);
					int false_address = CB.emit("br label @");
					string next = CB.genLabel();
					CB.bpatch(CB.merge(CB.makelist(make_pair(true_address,FIRST)),CB.makelist(make_pair(false_address,FIRST))),next);
					string tmp = freshVar();
					CB.emit(tmp + " = phi i1 [ true, %" + true_label+ " ], [ false, %"+ false_lable +" ]");
					$1.str = tmp;
			}
			$$.args = new vector<string>;
			$$.args->push_back($1.str);
			$$.args->insert($$.args->end(),$3.args->begin(),$3.args->end());
			delete $3.args;
			}
			;



EnumType    : ENUM ID {
				$$.argTypes = new vector<string>;
				if(!sm.is_symbol_defined($2.str) || !sm.is_enum_type($2.str)){
					output::errorUndefEnum(yylineno,$2.str);
					exit(1);
				}
				vector<string> values = sm.get_enum_values($2.str);
				$$.argTypes->insert($$.argTypes->begin(),values.begin(),values.end());
				$$.type= "enum " + $2.str;
				$$.isEnum = true;
				}
			;

Exp         : NUM {
				$$.type = "INT";
				$$.lineno = yylineno;
				$$.str = freshVar();
				CB.emit($$.str + " = add i32 0, " + $1.str );
				}
 			| LPAREN Exp RPAREN	{
 				$$.type = $2.type;
 			 	$$.lineno = $2.lineno;
 			 	$$.str =  $2.str;
 			 	}
			| ID {
				if(!sm.is_symbol_defined($1.str) || sm.get_var_type($1.str)=="enum" || sm.get_var_type($1.str).find("->") != string::npos){
					output::errorUndef(yylineno, $1.str);
					exit(1);
				}
				$$.type = sm.get_var_type($1.str);
				$$.isEnum = sm.is_enum($1.str);
				$$.lineno = yylineno;
				$$.str = freshVar();
				std::cout << "; " << "ID.str : " << $1.str << std::endl;

				if (sm.is_enum_type($1.str))
				{
					int enum_num = sm.enum_to_int($1.str);
					CB.emit($$.str+ " = add i32 0, " + to_string(enum_num));
				} else {
					CB.emit($$.str+ " = load i32, i32* %var"+$1.str);
					if($$.type == "BOOL"){
						string converted = freshVar();
						CB.emit(converted + " = trunc i32 "+$$.str+" to i1");
						string tmp = freshVar();
						CB.emit(tmp + " =  icmp eq i1 true, "+ converted);
						int curr_instr = CB.emit("br i1 "+tmp+", label @, label @");
						$$.truelist = CB.makelist(make_pair(curr_instr, FIRST));
						$$.falselist = CB.makelist(make_pair(curr_instr, SECOND));
					}	
				}
			}
			| Exp PLUS Exp {
					if(!($1.type=="INT" || $1.type=="BYTE")||!($3.type=="INT" || $3.type=="BYTE")){
						output::errorMismatch(yylineno);
						exit(1);
					}
					$$.type=($1.type=="INT" || $3.type=="INT")?"INT":"BYTE";
					$$.lineno = $1.lineno;
					$$.str = freshVar();
					if($2.str == "+"){
						CB.emit($$.str + " = add i32 " + $1.str + ", " + $3.str); //need to assert legalety for int-byte operration
					} else {
						CB.emit($$.str + " = sub i32 " + $1.str + ", " + $3.str); //need to assert legalety for int-byte operration
					}
					if($$.type=="BYTE"){
						//truncation of result
					}
				}
			| Call {
					$$ = $1;
				}
			| Exp MULT Exp {
					if(!($1.type=="INT" || $1.type=="BYTE")||!($3.type=="INT" || $3.type=="BYTE")){
						output::errorMismatch(yylineno);
						exit(1);
					}
					$$.type=($1.type=="INT" || $3.type=="INT")?"INT":"BYTE";
					$$.lineno = $1.lineno;
					$$.str = freshVar();
					if($2.str == "*"){
						CB.emit($$.str + " = mul i32 " + $1.str + ", " + $3.str); //need to assert legalety for int-byte operration
					} else {
						//emit code to handle zero division
						string tmp = freshVar();
						CB.emit(tmp + " =  icmp eq i32 0, "+ $3.str);
						string false_lable = freshVar().substr(1);
						CB.emit("br i1 "+ tmp + ", label %" + funcId + "." + ZeroDivisionLabel + ", label %" + false_lable);
						CB.emit(false_lable + ":");
						CB.emit($$.str + " = sdiv i32 " + $1.str + ", " + $3.str); //need to assert legalety for int-byte operration
					}
					if($$.type=="BYTE"){
						//truncation of result
					}
				}
			| LPAREN Type RPAREN Exp {
					if(!($2.type == "INT" && $4.isEnum == true)){
						output::errorMismatch(yylineno);
						exit(1);
					}
					$$.type = "INT";
					$$.lineno = $4.lineno;
					$$.str = $4.str;
				}
			| NUM B {
			    if(stoi($1.str) > 255){
                    output::errorByteTooLarge(yylineno, $1.str);
                    exit(1);
			    }
                $$.type = "BYTE";
                $$.lineno = yylineno;
                $$.str = freshVar();
				CB.emit($$.str + " = add i32 0, " + $1.str );
				//parse byte
			}
			| STRING {
				$$.type = "STRING";
				$$.lineno = yylineno;
				$$.str = $1.str;
				}
			| TRUE {
				$$.type = "BOOL";
				$$.lineno = yylineno;
				$$.str = $1.str;

				int curr_instr = CB.emit("br label @");
				$$.truelist = CB.makelist(make_pair(curr_instr, FIRST));
				}
			| FALSE {
				$$.type = "BOOL";
				$$.lineno = yylineno;
				$$.str = $1.str;

				int curr_instr = CB.emit("br label @");
				$$.falselist = CB.makelist(make_pair(curr_instr, FIRST));
				}
			| NOT Exp {
				if($2.type != "BOOL" ){
						output::errorMismatch(yylineno);
						exit(1);
					}
				$$.type = "BOOL";
				$$.lineno = $2.lineno;
				
				$$.falselist = $2.truelist;
				$$.truelist = $2.falselist;
			}
			| Exp AND M Exp {
				if($1.type != "BOOL" || $4.type !="BOOL" ){
						output::errorMismatch(yylineno);
						exit(1);
					}
				$$.type = "BOOL";
				$$.lineno = $1.lineno;
				
				CB.bpatch($1.truelist, $3.instr);
				$$.truelist = $4.truelist;
				$$.falselist = CB.merge($1.falselist,$4.falselist);
			}
			| Exp OR M Exp {
				if($1.type != "BOOL" || $4.type !="BOOL" ){
						output::errorMismatch(yylineno);
						exit(1);
					}
				$$.type = "BOOL";
				$$.lineno = $1.lineno;
				
				CB.bpatch($1.falselist, $3.instr);
				$$.falselist = $4.falselist;
				$$.truelist = CB.merge($1.truelist,$4.truelist);
				}
			| Exp RELOP Exp {
				if(!($1.type=="INT" || $1.type=="BYTE")||!($3.type=="INT" || $3.type=="BYTE")){
						output::errorMismatch(yylineno);
						exit(1);
					}
				$$.type = "BOOL";
				$$.lineno = $1.lineno;
				
				$$.str = freshVar();
				CB.emit($$.str + " = icmp " + token_to_op_str($2.str) + " i32 " + $1.str + ", " + $3.str);
				int loc = CB.emit("br i1 " + $$.str + ", label @, label @");
				$$.truelist = CB.makelist(make_pair(loc,FIRST));
				$$.falselist = CB.makelist(make_pair(loc,SECOND));
			}
			| Exp EQUAL Exp {
				if(!($1.type=="INT" || $1.type=="BYTE")||!($3.type=="INT" || $3.type=="BYTE")){
						output::errorMismatch(yylineno);
						exit(1);
					}
				$$.type = "BOOL";
				$$.lineno = $1.lineno;
				
				$$.str = freshVar();
				CB.emit($$.str + " = icmp " + token_to_op_str($2.str) + " i32 " + $1.str + ", " + $3.str);
				int loc = CB.emit("br i1 " + $$.str + ", label @, label @");
				$$.truelist = CB.makelist(make_pair(loc,FIRST));
				$$.falselist = CB.makelist(make_pair(loc,SECOND));
				}
			;

Statement   : LBRACE {
				sm.open_scope();
				$1.val=open_scope();
				$1.instr=CB.genLabel();
			} Statements RBRACE {

				int skip_address = CB.emit("br label @");
				offset -= close_scope($1.val,$1.instr);
				string skip = CB.genLabel();
				CB.bpatch(CB.makelist(make_pair(skip_address,FIRST)),skip);
				

				$$.nextlist = $3.nextlist;
			}
			| Type ID SC {
				if(sm.is_symbol_defined($2.str) || $2.str==funcId ){
					output::errorDef(yylineno,$2.str);
					exit(1);
				}
				sm.define_symbol($2.str,$1.type,false,offset++);
			}
			| EnumType ID SC {
				if(sm.is_symbol_defined($2.str) || $2.str==funcId){
					output::errorDef(yylineno,$2.str);
					exit(1);
				}
				sm.define_symbol($2.str,$1.type,true,offset++);
				} 
			| EnumDecl {}
			| Type ID ASSIGN Exp SC {
				if(sm.is_symbol_defined($2.str) || $2.str==funcId ){
					output::errorDef(yylineno,$2.str);
					exit(1);
				}
				if($1.type != $4.type && !($1.type== "INT" && $4.type == "BYTE")){
					output::errorMismatch(yylineno);
					
					exit(1);
				}	
				sm.define_symbol($2.str,$1.type,false,offset++);
				if($4.type == "BOOL") {
					string true_label = CB.genLabel();
					CB.bpatch($4.truelist,true_label);
					int true_address = CB.emit("br label @");

					string false_lable = CB.genLabel();
					CB.bpatch($4.falselist,false_lable);
					int false_address = CB.emit("br label @");

					string next = CB.genLabel();
					CB.bpatch(CB.merge(CB.makelist(make_pair(true_address,FIRST)),CB.makelist(make_pair(false_address,FIRST))),next);
					string tmp = freshVar();
					CB.emit(tmp + " = phi i1 [ true, %" + true_label+ " ], [ false, %"+ false_lable +" ]");
					$4.str = freshVar();
					CB.emit($4.str + " = zext i1 "+tmp+" to i32");
				}
				CB.emit("store i32 "+ $4.str + ", i32* %var" + $2.str);
			}
			| EnumType ID ASSIGN Exp SC {
				if(sm.is_symbol_defined($2.str) || $2.str==funcId) {
					output::errorDef(yylineno,$2.str);
					delete $1.argTypes;
					exit(1);
				}
				if($1.type != $4.type){
					output::errorUndefEnumValue(yylineno,$2.str);
					delete $1.argTypes;
					exit(1);
				}	
				sm.define_symbol($2.str,$1.type,true,offset++);
				delete $1.argTypes;

				CB.emit("store i32 "+ $4.str + ", i32* %var" + $2.str);
			}
			| ID ASSIGN Exp SC {
				if(!sm.is_symbol_defined($1.str) || sm.get_var_type($1.str).find("->") != string::npos || sm.get_var_type($1.str)=="enum"){
					output::errorUndef(yylineno,$1.str);
					exit(1);
				}
				string type = sm.get_var_type($1.str);
				bool isEnum = sm.is_enum($1.str);
				if(isEnum==true && type != $3.type){
					output::errorUndefEnumValue(yylineno,$1.str);
					exit(1);
				}
				if(type != $3.type && !(type== "INT" && $3.type == "BYTE")){
					output::errorMismatch(yylineno);
					exit(1);
				}
				if($3.type == "BOOL") {
					string true_label = CB.genLabel();
					CB.bpatch($3.truelist,true_label);
					int true_address = CB.emit("br label @");

					string false_lable = CB.genLabel();
					CB.bpatch($3.falselist,false_lable);
					int false_address = CB.emit("br label @");
					string next = CB.genLabel();
					CB.bpatch(CB.merge(CB.makelist(make_pair(true_address,FIRST)),CB.makelist(make_pair(false_address,FIRST))),next);
					string tmp = freshVar();
					CB.emit(tmp + " = phi i1 [ true, %" + true_label+ " ], [ false, %"+ false_lable +" ]");
					$3.str = freshVar();
					CB.emit($3.str + " = zext i1 "+tmp+" to i32");
				}	
				CB.emit("store i32 "+ $3.str + ", i32* %var" + $1.str);
				} 
			| Call SC {}
			| RETURN SC {
				if(funcRet!="VOID"){
					output::errorMismatch(yylineno);
					exit(1);
				}
				manual_return = true;
				CB.emit("br label %"+ funcId + ".return");
			}
			| RETURN Exp SC {
				if(funcRet == "VOID" || (funcRet!=$2.type && !(funcRet=="INT" && ($2.type=="BYTE" || $2.isEnum == true)))){
					output::errorMismatch($2.lineno);
					exit(1);
				}
				manual_return = true;
				if(funcRet == "VOID" || funcRet == "BYTE" ){
					//parse result
				}
				CB.emit("store i32 " + $2.str + ", i32* %retvar");
  				CB.emit("br label %"+ funcId + ".return");
			}
			| IF LPAREN Exp RPAREN Subrotine Statement  {
				if($3.type!="BOOL"){
					output::errorMismatch($3.lineno);
					exit(1);
				}
				CB.bpatch($3.truelist, $5.instr);
				$$.nextlist = CB.makelist(make_pair(CB.emit("br label @"),FIRST));
				$$.nextlist = CB.merge($3.falselist,$$.nextlist);
				$$.nextlist = CB.merge($$.nextlist, $6.nextlist);
				offset -= close_scope($5.val,$5.instr);
				string label = CB.genLabel();
				CB.bpatch($$.nextlist,label);

			}
			| IF LPAREN Exp RPAREN Subrotine Statement N_ELSE {
		        if($3.type!="BOOL"){
                    output::errorMismatch($3.lineno);
                    exit(1);
                }
                int skip_address = CB.emit("br label @");
				offset -=close_scope($5.val,$5.instr);
				string skip = CB.genLabel();
				CB.bpatch(CB.makelist(make_pair(skip_address,FIRST)),skip);
                sm.open_scope();
                $7.val=open_scope();
				$7.instr=CB.genLabel();
                CB.bpatch($3.truelist, $5.instr);
			} M Statement {
               

                CB.bpatch($3.falselist, $9.instr);
                vector<pair<int,BranchLabelIndex>> tmp = CB.merge($6.nextlist, $7.nextlist);
                $$.nextlist = CB.makelist(make_pair(CB.emit("br label @"),FIRST));
                $$.nextlist = CB.merge($$.nextlist, $10.nextlist);
                $$.nextlist = CB.merge($$.nextlist, tmp);
                offset -= close_scope($7.val,$7.instr);
                string label = CB.genLabel();
				CB.bpatch($$.nextlist,label);

			}
			| WHILE M LPAREN Exp RPAREN {
			    if($4.type!="BOOL"){
                    output::errorMismatch($4.lineno);
                    exit(1);
                }
				sm.open_scope();
				$5.val=open_scope();
				$5.instr=CB.genLabel();
				isLoop++;

				$$.nextlist = $4.falselist;
			} M Statement {
				
				isLoop--;

				CB.bpatch($8.nextlist, $2.instr);
				CB.bpatch($4.truelist, $7.instr);
				CB.emit("br label %" + $2.instr);
				offset -= close_scope($5.val,$5.instr);
				string end_while = CB.genLabel();
				CB.bpatch($4.falselist,end_while);
				

	 		} 
			| BREAK SC {
				if(isLoop==0){
					output::errorUnexpectedBreak(yylineno);
					exit(1);
				}
			}
			| CONTINUE SC {
				if(isLoop==0){
					output::errorUnexpectedContinue(yylineno);
					exit(1);
				}
			}
			;

Type 		: INT {$$.type = "INT";}
			| BYTE {$$.type = "BYTE";}
			| BOOL {$$.type = "BOOL";}
			;

Subrotine	: /* empty */ {
				sm.open_scope();
 				$$.val=open_scope();
			//	CB.emit("#Added label here");
               	$$.instr = CB.genLabel();
			}
			;

M 			: /* epsilon */ {
            //   CB.emit("#Added label here");
               int address = CB.emit("br label @");
               $$.instr = CB.genLabel();
               CB.bpatch(CB.makelist(make_pair(address,FIRST)),$$.instr);
           	}
           	;

N_ELSE 		: ELSE {
               //CB.emit("#Added label here");
               int loc = CB.emit("br label @");
               $$.nextlist = CB.makelist(make_pair(loc,FIRST));
           	}
           	;

%%

/*C user routines*/

void yyerror(const char*) { 
	output::errorSyn(yylineno);
	exit(1);  
}

bool invalid_main(SymbolTable sm) {
    string main_ret_value = sm.get_func_ret("main");
    vector<string> main_args = sm.get_func_args("main");

    return !(main_ret_value == "VOID" && main_args.empty());
}

int main() {
	//yydebug = 1; 
	
	isLoop = 0;
	sm = SymbolTable();
	sm.open_scope();
	vector<string> print_args;
	print_args.push_back("STRING");
	sm.define_func_symbol("print","VOID",false,print_args);
	vector<string> printi_args;
	printi_args.push_back("INT");
	sm.define_func_symbol("printi","VOID",false,printi_args);
	emitPrintFuncs();
	CB.emitGlobal("@.zero_division = constant ["+to_string(zero_error.length()+2)+" x i8] c\""+ zero_error +"\\0A\\00\"");
	yyparse();
	if(invalid_main(sm)){
		output::errorMainMissing();
		exit(1);
	}
	offset -= sm.close_scope();
	CB.printGlobalBuffer();
	CB.printCodeBuffer();
}

string freshVar(){
	return "\%temp"+to_string(++currentVar);
}

void createZeroDivisionLabel(){
	CB.emit(funcId + "." +ZeroDivisionLabel+ ":");
    CB.emit("call void @print(i8* getelementptr (["+ to_string(zero_error.length()+2) +" x i8], ["+to_string(zero_error.length()+2)+" x i8]* @.zero_division, i32 0, i32 0))" );
    CB.emit("call void @exit(i32 1)");
    CB.emit("br label %" + funcId + ".return");
}

string arglist(int size){
	string lst = "";
		for(int i=0;i<size-1;i++){
			string type = func_arg_types[i]=="BOOL"?"i1":"i32";
			lst+= type +" %arg" + to_string(i) + ", ";
		}
		return size>0?lst + (func_arg_types[size-1]=="BOOL"?"i1":"i32") + " %arg" +to_string(size-1):"";
	}

string callList(vector<string> list,vector<string> types){
	for(int i =0;i<list.size();i++){
		string type = types[i]=="BOOL"?"i1":"i32";
		list[i]=  type +" " + list[i];
	}
	return accumulate(list.begin()+1,list.end(),*list.begin(),accumulateHelper);
}

string accumulateHelper(string a,string b){
	return a + ", " + b;
}

void allocateStackVars(){
	//need to call this func at the end of every scope but make sure the code is placed at the begining of the scope maybe branch and label maybe backpatching
	for(Symbol symbol: sm.get_current_symbols()){
		CB.emit("%var" + symbol.get_symbol_name()+ " = alloca i32" );
		if (symbol.get_symbol_offset()<0){
			string arg = "%arg"+to_string(-1*(symbol.get_symbol_offset()+1));
			if(symbol.get_type()=="BOOL"){
				string tmp = freshVar();
				CB.emit(tmp + " = zext i1 "+arg+" to i32");
				arg = tmp;
			} 
			CB.emit("store i32 "+ arg + ", i32* %var" + symbol.get_symbol_name());
		} else {
			CB.emit("store i32 0, i32* %var" + symbol.get_symbol_name());
		}
	}
}

void emitPrintFuncs(){
	CB.emit("declare i32 @printf(i8*, ...)");
	CB.emit("declare void @exit(i32)");
	CB.emitGlobal("@.str_specifier = constant [4 x i8] c\"%s\\0A\\00\"");
	CB.emitGlobal("@.int_specifier = constant [4 x i8] c\"%d\\0A\\00\"");
	CB.emit("define void @printi(i32) {");
	CB.emit("call i32 (i8*, ...) @printf(i8* getelementptr ([4 x i8], [4 x i8]* @.int_specifier, i32 0, i32 0), i32 %0)");
	CB.emit("ret void");
	CB.emit("}");
	CB.emit("define void @print(i8*) {");
	CB.emit("call i32 (i8*, ...) @printf(i8* getelementptr ([4 x i8], [4 x i8]* @.str_specifier, i32 0, i32 0), i8* %0)");
	CB.emit("ret void");
	CB.emit("}");

}

string token_to_op_str(string token) {
	string op_str = "";

	if (token == "<") {
		op_str = "slt";
	} else if (token == ">") {
		op_str = "sgt";
	} else if (token == "<=") {
		op_str = "sle";
	} else if (token == ">=") {
		op_str = "sge";
	} else if (token == "==") {
		op_str = "eq";
	} else if (token == "!=") {
		op_str = "ne";
	}

	return op_str;
}

int open_scope(){
	return CB.emit("br label @");
}
int close_scope(int address,string return_label){

	string label = CB.genLabel();
	CB.bpatch(CB.makelist(make_pair(address,FIRST)),label);
	allocateStackVars();
	CB.emit("br label %"+ return_label);
	
	return sm.close_scope();
}
